error: defining existential type use differs from previous
  --> $DIR/existential_type.rs:23:1
   |
LL | / fn bar() -> Foo { //~ ERROR defining existential type use differs from previous
LL | |     42i32
LL | | }
   | |_^
   |
note: previous use here
  --> $DIR/existential_type.rs:19:1
   |
LL | / fn foo() -> Foo {
LL | |     ""
LL | | }
   | |_^

error[E0308]: mismatched types
  --> $DIR/existential_type.rs:36:5
   |
LL | fn bomp() -> boo::Boo {
   |              -------- expected `Boo` because of return type
LL |     "" //~ ERROR mismatched types
   |     ^^ expected anonymized type, found reference
   |
   = note: expected type `Boo`
              found type `&'static str`

error[E0308]: mismatched types
  --> $DIR/existential_type.rs:50:23
   |
LL |         let _: &str = bomp(); //~ ERROR mismatched types
   |                       ^^^^^^ expected &str, found anonymized type
   |
   = note: expected type `&str`
              found type `Boo`

error[E0308]: mismatched types
  --> $DIR/existential_type.rs:54:9
   |
LL |     fn bomp() -> boo::Boo {
   |                  -------- expected `Boo` because of return type
LL |         "" //~ ERROR mismatched types
   |         ^^ expected anonymized type, found reference
   |
   = note: expected type `Boo`
              found type `&'static str`

error[E0277]: the trait bound `T: Trait` is not satisfied
  --> $DIR/existential_type.rs:61:1
   |
LL | existential type Underconstrained<T: Trait>: 'static; //~ ERROR the trait bound `T: Trait`
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `T`
   |
   = help: consider adding a `where T: Trait` bound
   = note: the return type of a function must have a statically known size

error[E0310]: the parameter type `T` may not live long enough
  --> $DIR/existential_type.rs:78:1
   |
LL | existential type WrongGeneric<T>: 'static;
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {
   |                  - help: consider adding an explicit lifetime bound `T: 'static`...
   |
note: ...so that the type `T` will meet its required lifetime bounds
  --> $DIR/existential_type.rs:78:1
   |
LL | existential type WrongGeneric<T>: 'static;
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
  --> $DIR/existential_type.rs:93:27
   |
LL |     let _: &'static str = x; //~ mismatched types
   |                           ^ expected reference, found anonymized type
   |
   = note: expected type `&'static str`
              found type `NoReveal`

error[E0605]: non-primitive cast: `NoReveal` as `&'static str`
  --> $DIR/existential_type.rs:94:13
   |
LL |     let _ = x as &'static str; //~ non-primitive cast
   |             ^^^^^^^^^^^^^^^^^
   |
   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait

error: could not find defining uses
  --> $DIR/existential_type.rs:28:1
   |
LL | existential type Bar: std::fmt::Debug; //~ ERROR could not find defining uses
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: could not find defining uses
  --> $DIR/existential_type.rs:32:5
   |
LL |     pub existential type Boo: ::std::fmt::Debug; //~ ERROR could not find defining uses
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error: defining existential type use differs from previous
  --> $DIR/existential_type.rs:74:1
   |
LL | / fn my_iter2<T>(t: T) -> MyIter<T> { //~ ERROR defining existential type use differs from previous
LL | |     Some(t).into_iter()
LL | | }
   | |_^
   |
note: previous use here
  --> $DIR/existential_type.rs:70:1
   |
LL | / fn my_iter<T>(t: T) -> MyIter<T> {
LL | |     std::iter::once(t)
LL | | }
   | |_^

error: aborting due to 11 previous errors

Some errors occurred: E0277, E0308, E0310, E0605.
For more information about an error, try `rustc --explain E0277`.
