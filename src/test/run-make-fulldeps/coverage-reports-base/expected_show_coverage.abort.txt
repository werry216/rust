    1|       |#![feature(unwind_attributes)]
    2|       |#![allow(unused_assignments)]
    3|       |
    4|       |#[unwind(aborts)]
    5|       |fn might_abort(should_abort: bool) {
    6|      4|    if should_abort {
    7|      0|        println!("aborting...");
    8|      0|        panic!("panics and aborts");
    9|      4|    } else {
   10|      4|        println!("Don't Panic");
   11|      4|    }
   12|      4|}
   13|       |
   14|       |fn main() -> Result<(),u8> {
   15|      1|    let mut countdown = 10;
   16|     11|    while countdown > 0 {
   17|     10|        if countdown < 5 {
   18|      4|            might_abort(false);
   19|      6|        }
   20|     10|        countdown -= 1;
   21|       |    }
   22|      1|    Ok(())
   23|      1|}
   24|       |
   25|       |// Notes:
   26|       |//   1. Compare this program and its coverage results to those of the similar tests
   27|       |//      `panic_unwind.rs` and `try_error_result.rs`.
   28|       |//   2. This test confirms the coverage generated when a program includes `TerminatorKind::Abort`.
   29|       |//   3. The test does not invoke the abort. By executing to a successful completion, the coverage
   30|       |//      results show where the program did and did not execute.
   31|       |//   4. If the program actually aborted, the coverage counters would not be saved (which "works as
   32|       |//      intended"). Coverage results would show no executed coverage regions.
   33|       |//   6. If `should_abort` is `true` and the program aborts, the program exits with a `132` status
   34|       |//      (on Linux at least).

