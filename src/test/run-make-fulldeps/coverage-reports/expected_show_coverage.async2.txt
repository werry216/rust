    1|       |// compile-flags: --edition=2018
    2|       |
    3|       |use core::{
    4|       |    future::Future,
    5|       |    marker::Send,
    6|       |    pin::Pin,
    7|       |};
    8|       |
    9|      1|fn non_async_func() {
   10|      1|    println!("non_async_func was covered");
   11|      1|    let b = true;
   12|      1|    if b {
   13|      1|        println!("non_async_func println in block");
   14|      1|    }
   15|      1|}
   16|       |
   17|       |// FIXME(#83985): The auto-generated closure in an async function is failing to include
   18|       |// the println!() and `let` assignment lines in the coverage code region(s), as it does in the
   19|       |// non-async function above, unless the `println!()` is inside a covered block.
   20|      1|async fn async_func() {
   21|       |    println!("async_func was covered");
   22|       |    let b = true;
   23|      1|    if b {
   24|      1|        println!("async_func println in block");
   25|      1|    }
                   ^0
   26|      1|}
   27|       |
   28|       |// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not
   29|       |// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.
   30|       |// It's only certain kinds of lines and/or their context that results in missing coverage.
   31|      1|async fn async_func_just_println() {
   32|       |    println!("async_func_just_println was covered");
   33|       |}
   34|       |
   35|      1|fn main() {
   36|      1|    println!("codecovsample::main");
   37|      1|
   38|      1|    non_async_func();
   39|      1|
   40|      1|    executor::block_on(async_func());
   41|      1|    executor::block_on(async_func_just_println());
   42|      1|
   43|      1|    // let mut future = Box::pin(async_func());
   44|      1|    // executor::block_on(future.as_mut());
   45|      1|
   46|      1|    // let mut future = Box::pin(async_func());
   47|      1|    // executor::block_on(future.as_mut());
   48|      1|
   49|      1|    // let mut future = Box::pin(async_func_just_println());
   50|      1|    // executor::block_on(future.as_mut());
   51|      1|}
   52|       |
   53|       |mod executor {
   54|       |    use core::{
   55|       |        future::Future,
   56|       |        pin::Pin,
   57|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},
   58|       |    };
   59|       |
   60|      2|    pub fn block_on<F: Future>(mut future: F) -> F::Output {
   61|      2|        let mut future = unsafe { Pin::new_unchecked(&mut future) };
   62|      2|        use std::hint::unreachable_unchecked;
   63|      2|        static VTABLE: RawWakerVTable = RawWakerVTable::new(
   64|      2|            |_| unsafe { unreachable_unchecked() }, // clone
                              ^0
   65|      2|            |_| unsafe { unreachable_unchecked() }, // wake
                              ^0
   66|      2|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref
                              ^0
   67|      2|            |_| (),
   68|      2|        );
   69|      2|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };
   70|      2|        let mut context = Context::from_waker(&waker);
   71|       |
   72|       |        loop {
   73|      2|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {
   74|      2|                break val;
   75|      0|            }
   76|       |        }
   77|      2|    }
  ------------------
  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func::{closure#0}>>:
  |   60|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {
  |   61|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };
  |   62|      1|        use std::hint::unreachable_unchecked;
  |   63|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(
  |   64|      1|            |_| unsafe { unreachable_unchecked() }, // clone
  |   65|      1|            |_| unsafe { unreachable_unchecked() }, // wake
  |   66|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref
  |   67|      1|            |_| (),
  |   68|      1|        );
  |   69|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };
  |   70|      1|        let mut context = Context::from_waker(&waker);
  |   71|       |
  |   72|       |        loop {
  |   73|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {
  |   74|      1|                break val;
  |   75|      0|            }
  |   76|       |        }
  |   77|      1|    }
  ------------------
  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func_just_println::{closure#0}>>:
  |   60|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {
  |   61|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };
  |   62|      1|        use std::hint::unreachable_unchecked;
  |   63|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(
  |   64|      1|            |_| unsafe { unreachable_unchecked() }, // clone
  |   65|      1|            |_| unsafe { unreachable_unchecked() }, // wake
  |   66|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref
  |   67|      1|            |_| (),
  |   68|      1|        );
  |   69|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };
  |   70|      1|        let mut context = Context::from_waker(&waker);
  |   71|       |
  |   72|       |        loop {
  |   73|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {
  |   74|      1|                break val;
  |   75|      0|            }
  |   76|       |        }
  |   77|      1|    }
  ------------------
   78|       |}

