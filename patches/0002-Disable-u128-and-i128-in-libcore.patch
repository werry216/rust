From 8080d322c8396b7b234cc92eb675f697c55f7298 Mon Sep 17 00:00:00 2001
From: bjorn3 <bjorn3@users.noreply.github.com>
Date: Sat, 16 Feb 2019 12:09:42 +0100
Subject: [PATCH] Disable u128 and i128 in libcore

---
 src/libcore/clone.rs             |   4 +-
 src/libcore/cmp.rs               |   6 +-
 src/libcore/default.rs           |   2 -
 src/libcore/fmt/num.rs           |   8 +-
 src/libcore/hash/mod.rs          |  20 -----
 src/libcore/iter/range.rs        |   1 -
 src/libcore/iter/traits/accum.rs |   2 +-
 src/libcore/lib.rs               |   2 -
 src/libcore/marker.rs            |   4 +-
 src/libcore/mem.rs               |   2 -
 src/libcore/num/mod.rs           | 100 +++++++------------------
 src/libcore/num/wrapping.rs      |  14 ++--
 src/libcore/ops/arith.rs         |  22 +++---
 src/libcore/ops/bit.rs           |  30 +++-----
 src/libcore/sync/atomic.rs       |  30 --------
 src/libcore/time.rs              | 123 -------------------------------
 src/libstd/lib.rs                |   4 -
 src/libstd/net/ip.rs             |  20 -----
 src/libstd/num.rs                |   2 +-
 src/libstd/panic.rs              |   6 --
 22 files changed, 63 insertions(+), 372 deletions(-)

diff --git a/src/libcore/clone.rs b/src/libcore/clone.rs
index ed90b7d..1739f91 100644
--- a/src/libcore/clone.rs
+++ b/src/libcore/clone.rs
@@ -173,8 +173,8 @@ mod impls {
     }
 
     impl_clone! {
-        usize u8 u16 u32 u64 u128
-        isize i8 i16 i32 i64 i128
+        usize u8 u16 u32 u64
+        isize i8 i16 i32 i64
         f32 f64
         bool char
     }
diff --git a/src/libcore/cmp.rs b/src/libcore/cmp.rs
index 81fcdee..749134c 100644
--- a/src/libcore/cmp.rs
+++ b/src/libcore/cmp.rs
@@ -876,7 +876,7 @@ mod impls {
     }
 
     partial_eq_impl! {
-        bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64
+        bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64
     }
 
     macro_rules! eq_impl {
@@ -886,7 +886,7 @@ mod impls {
         )*)
     }
 
-    eq_impl! { () bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+    eq_impl! { () bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
     macro_rules! partial_ord_impl {
         ($($t:ty)*) => ($(
@@ -975,7 +975,7 @@ mod impls {
         }
     }
 
-    ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+    ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
     #[unstable(feature = "never_type", issue = "35121")]
     impl PartialEq for ! {
diff --git a/src/libcore/default.rs b/src/libcore/default.rs
index 5ad05b3..1b5a1d1 100644
--- a/src/libcore/default.rs
+++ b/src/libcore/default.rs
@@ -135,14 +135,12 @@ default_impl! { u8, 0, "Returns the default value of `0`" }
 default_impl! { u16, 0, "Returns the default value of `0`" }
 default_impl! { u32, 0, "Returns the default value of `0`" }
 default_impl! { u64, 0, "Returns the default value of `0`" }
-default_impl! { u128, 0, "Returns the default value of `0`" }
 
 default_impl! { isize, 0, "Returns the default value of `0`" }
 default_impl! { i8, 0, "Returns the default value of `0`" }
 default_impl! { i16, 0, "Returns the default value of `0`" }
 default_impl! { i32, 0, "Returns the default value of `0`" }
 default_impl! { i64, 0, "Returns the default value of `0`" }
-default_impl! { i128, 0, "Returns the default value of `0`" }
 
 default_impl! { f32, 0.0f32, "Returns the default value of `0.0`" }
 default_impl! { f64, 0.0f64, "Returns the default value of `0.0`" }
diff --git a/src/libcore/fmt/num.rs b/src/libcore/fmt/num.rs
index b9fa364..cd9ee01 100644
--- a/src/libcore/fmt/num.rs
+++ b/src/libcore/fmt/num.rs
@@ -17,7 +17,6 @@ trait Int: PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +
     fn to_u16(&self) -> u16;
     fn to_u32(&self) -> u32;
     fn to_u64(&self) -> u64;
-    fn to_u128(&self) -> u128;
 }
 
 macro_rules! doit {
@@ -28,10 +27,9 @@ macro_rules! doit {
         fn to_u16(&self) -> u16 { *self as u16 }
         fn to_u32(&self) -> u32 { *self as u32 }
         fn to_u64(&self) -> u64 { *self as u64 }
-        fn to_u128(&self) -> u128 { *self as u128 }
     })*)
 }
-doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }
+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }
 
 /// A type that represents a specific radix
 #[doc(hidden)]
@@ -176,8 +174,6 @@ integer! { i8, u8 }
 integer! { i16, u16 }
 integer! { i32, u32 }
 integer! { i64, u64 }
-integer! { i128, u128 }
-
 
 static DEC_DIGITS_LUT: &[u8; 200] =
     b"0001020304050607080910111213141516171819\
@@ -274,5 +270,3 @@ mod imp {
     impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);
     impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);
 }
-
-impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);
diff --git a/src/libcore/hash/mod.rs b/src/libcore/hash/mod.rs
index d5d29c9..f98f382 100644
--- a/src/libcore/hash/mod.rs
+++ b/src/libcore/hash/mod.rs
@@ -296,12 +296,6 @@ pub trait Hasher {
     fn write_u64(&mut self, i: u64) {
         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })
     }
-    /// Writes a single `u128` into this hasher.
-    #[inline]
-    #[stable(feature = "i128", since = "1.26.0")]
-    fn write_u128(&mut self, i: u128) {
-        self.write(&unsafe { mem::transmute::<_, [u8; 16]>(i) })
-    }
     /// Writes a single `usize` into this hasher.
     #[inline]
     #[stable(feature = "hasher_write", since = "1.3.0")]
@@ -336,12 +330,6 @@ pub trait Hasher {
     fn write_i64(&mut self, i: i64) {
         self.write_u64(i as u64)
     }
-    /// Writes a single `i128` into this hasher.
-    #[inline]
-    #[stable(feature = "i128", since = "1.26.0")]
-    fn write_i128(&mut self, i: i128) {
-        self.write_u128(i as u128)
-    }
     /// Writes a single `isize` into this hasher.
     #[inline]
     #[stable(feature = "hasher_write", since = "1.3.0")]
@@ -370,9 +358,6 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {
     fn write_u64(&mut self, i: u64) {
         (**self).write_u64(i)
     }
-    fn write_u128(&mut self, i: u128) {
-        (**self).write_u128(i)
-    }
     fn write_usize(&mut self, i: usize) {
         (**self).write_usize(i)
     }
@@ -388,9 +373,6 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {
     fn write_i64(&mut self, i: i64) {
         (**self).write_i64(i)
     }
-    fn write_i128(&mut self, i: i128) {
-        (**self).write_i128(i)
-    }
     fn write_isize(&mut self, i: isize) {
         (**self).write_isize(i)
     }
@@ -577,8 +559,6 @@ mod impls {
         (i32, write_i32),
         (i64, write_i64),
         (isize, write_isize),
-        (u128, write_u128),
-        (i128, write_i128),
     }
 
     #[stable(feature = "rust1", since = "1.0.0")]
diff --git a/src/libcore/iter/range.rs b/src/libcore/iter/range.rs
index a3e9cfa..31b6ca4 100644
--- a/src/libcore/iter/range.rs
+++ b/src/libcore/iter/range.rs
@@ -173,7 +173,6 @@ step_impl_signed!([i64: u64]);
 // assume here that it is less than 64-bits.
 #[cfg(not(target_pointer_width = "64"))]
 step_impl_no_between!(u64 i64);
-step_impl_no_between!(u128 i128);
 
 macro_rules! range_exact_iter_impl {
     ($($t:ty)*) => ($(
diff --git a/src/libcore/iter/traits/accum.rs b/src/libcore/iter/traits/accum.rs
index dfe1d2a..06cc578 100644
--- a/src/libcore/iter/traits/accum.rs
+++ b/src/libcore/iter/traits/accum.rs
@@ -111,7 +111,7 @@ macro_rules! float_sum_product {
     )*)
 }
 
-integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }
+integer_sum_product! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }
 float_sum_product! { f32 f64 }
 
 /// An iterator adapter that produces output as long as the underlying
diff --git a/src/libcore/lib.rs b/src/libcore/lib.rs
index cd88d3e..532d680 100644
--- a/src/libcore/lib.rs
+++ b/src/libcore/lib.rs
@@ -148,14 +148,12 @@ mod uint_macros;
 #[path = "num/i16.rs"]   pub mod i16;
 #[path = "num/i32.rs"]   pub mod i32;
 #[path = "num/i64.rs"]   pub mod i64;
-#[path = "num/i128.rs"]  pub mod i128;
 
 #[path = "num/usize.rs"] pub mod usize;
 #[path = "num/u8.rs"]    pub mod u8;
 #[path = "num/u16.rs"]   pub mod u16;
 #[path = "num/u32.rs"]   pub mod u32;
 #[path = "num/u64.rs"]   pub mod u64;
-#[path = "num/u128.rs"]  pub mod u128;
 
 #[path = "num/f32.rs"]   pub mod f32;
 #[path = "num/f64.rs"]   pub mod f64;
diff --git a/src/libcore/marker.rs b/src/libcore/marker.rs
index c4b41f1..0ade53b 100644
--- a/src/libcore/marker.rs
+++ b/src/libcore/marker.rs
@@ -664,8 +664,8 @@ mod copy_impls {
     }
 
     impl_copy! {
-        usize u8 u16 u32 u64 u128
-        isize i8 i16 i32 i64 i128
+        usize u8 u16 u32 u64
+        isize i8 i16 i32 i64
         f32 f64
         bool char
     }
diff --git a/src/libcore/mem.rs b/src/libcore/mem.rs
index 3f7455a..7a0c44a 100644
--- a/src/libcore/mem.rs
+++ b/src/libcore/mem.rs
@@ -164,12 +164,10 @@ pub fn forget_unsized<T: ?Sized>(t: T) {
 /// u16 | 2
 /// u32 | 4
 /// u64 | 8
-/// u128 | 16
 /// i8 | 1
 /// i16 | 2
 /// i32 | 4
 /// i64 | 8
-/// i128 | 16
 /// f32 | 4
 /// f64 | 8
 /// char | 4
diff --git a/src/libcore/num/mod.rs b/src/libcore/num/mod.rs
index 6fb67ea..6440490 100644
--- a/src/libcore/num/mod.rs
+++ b/src/libcore/num/mod.rs
@@ -102,13 +102,11 @@ nonzero_integers! {
     #[stable(feature = "nonzero", since = "1.28.0")] NonZeroU16(u16);
     #[stable(feature = "nonzero", since = "1.28.0")] NonZeroU32(u32);
     #[stable(feature = "nonzero", since = "1.28.0")] NonZeroU64(u64);
-    #[stable(feature = "nonzero", since = "1.28.0")] NonZeroU128(u128);
     #[stable(feature = "nonzero", since = "1.28.0")] NonZeroUsize(usize);
     #[stable(feature = "signed_nonzero", since = "1.34.0")] NonZeroI8(i8);
     #[stable(feature = "signed_nonzero", since = "1.34.0")] NonZeroI16(i16);
     #[stable(feature = "signed_nonzero", since = "1.34.0")] NonZeroI32(i32);
     #[stable(feature = "signed_nonzero", since = "1.34.0")] NonZeroI64(i64);
-    #[stable(feature = "signed_nonzero", since = "1.34.0")] NonZeroI128(i128);
     #[stable(feature = "signed_nonzero", since = "1.34.0")] NonZeroIsize(isize);
 }
 
@@ -2124,18 +2122,6 @@ impl i64 {
          "[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]" }
 }
 
-#[lang = "i128"]
-impl i128 {
-    int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,
-        170141183460469231731687303715884105727, "", "", 16,
-        "0x13f40000000000000000000000004f76", "0x4f7613f4", "0x12345678901234567890123456789012",
-        "0x12907856341290785634129078563412", "0x48091e6a2c48091e6a2c48091e6a2c48",
-        "[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \
-          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]",
-        "[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \
-          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]" }
-}
-
 #[cfg(target_pointer_width = "16")]
 #[lang = "isize"]
 impl isize {
@@ -4411,17 +4397,6 @@ impl u64 {
         "[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]" }
 }
 
-#[lang = "u128"]
-impl u128 {
-    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, "", "", 16,
-        "0x13f40000000000000000000000004f76", "0x4f7613f4", "0x12345678901234567890123456789012",
-        "0x12907856341290785634129078563412", "0x48091e6a2c48091e6a2c48091e6a2c48",
-        "[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \
-          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]",
-        "[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \
-          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]" }
-}
-
 #[cfg(target_pointer_width = "16")]
 #[lang = "usize"]
 impl usize {
@@ -4505,7 +4480,7 @@ macro_rules! from_str_radix_int_impl {
         }
     )*}
 }
-from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }
+from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }
 
 /// The error type returned when a checked integral type conversion fails.
 #[unstable(feature = "try_from", issue = "33417")]
@@ -4621,30 +4596,25 @@ macro_rules! rev {
 try_from_upper_bounded!(u16, u8);
 try_from_upper_bounded!(u32, u16, u8);
 try_from_upper_bounded!(u64, u32, u16, u8);
-try_from_upper_bounded!(u128, u64, u32, u16, u8);
 
 try_from_both_bounded!(i16, i8);
 try_from_both_bounded!(i32, i16, i8);
 try_from_both_bounded!(i64, i32, i16, i8);
-try_from_both_bounded!(i128, i64, i32, i16, i8);
 
 // unsigned-to-signed
 try_from_upper_bounded!(u8, i8);
 try_from_upper_bounded!(u16, i8, i16);
 try_from_upper_bounded!(u32, i8, i16, i32);
 try_from_upper_bounded!(u64, i8, i16, i32, i64);
-try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);
 
 // signed-to-unsigned
-try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);
-try_from_lower_bounded!(i16, u16, u32, u64, u128);
-try_from_lower_bounded!(i32, u32, u64, u128);
-try_from_lower_bounded!(i64, u64, u128);
-try_from_lower_bounded!(i128, u128);
+try_from_lower_bounded!(i8, u8, u16, u32, u64);
+try_from_lower_bounded!(i16, u16, u32, u64);
+try_from_lower_bounded!(i32, u32, u64);
+try_from_lower_bounded!(i64, u64);
 try_from_both_bounded!(i16, u8);
 try_from_both_bounded!(i32, u16, u8);
 try_from_both_bounded!(i64, u32, u16, u8);
-try_from_both_bounded!(i128, u64, u32, u16, u8);
 
 // usize/isize
 try_from_upper_bounded!(usize, isize);
@@ -4656,21 +4626,21 @@ mod ptr_try_from_impls {
     use convert::TryFrom;
 
     try_from_upper_bounded!(usize, u8);
-    try_from_unbounded!(usize, u16, u32, u64, u128);
+    try_from_unbounded!(usize, u16, u32, u64);
     try_from_upper_bounded!(usize, i8, i16);
-    try_from_unbounded!(usize, i32, i64, i128);
+    try_from_unbounded!(usize, i32, i64);
 
     try_from_both_bounded!(isize, u8);
-    try_from_lower_bounded!(isize, u16, u32, u64, u128);
+    try_from_lower_bounded!(isize, u16, u32, u64);
     try_from_both_bounded!(isize, i8);
-    try_from_unbounded!(isize, i16, i32, i64, i128);
+    try_from_unbounded!(isize, i16, i32, i64);
 
-    rev!(try_from_upper_bounded, usize, u32, u64, u128);
+    rev!(try_from_upper_bounded, usize, u32, u64);
     rev!(try_from_lower_bounded, usize, i8, i16);
-    rev!(try_from_both_bounded, usize, i32, i64, i128);
+    rev!(try_from_both_bounded, usize, i32, i64);
 
-    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);
-    rev!(try_from_both_bounded, isize, i32, i64, i128);
+    rev!(try_from_upper_bounded, isize, u16, u32, u64);
+    rev!(try_from_both_bounded, isize, i32, i64);
 }
 
 #[cfg(target_pointer_width = "32")]
@@ -4679,24 +4649,24 @@ mod ptr_try_from_impls {
     use convert::TryFrom;
 
     try_from_upper_bounded!(usize, u8, u16);
-    try_from_unbounded!(usize, u32, u64, u128);
+    try_from_unbounded!(usize, u32, u64);
     try_from_upper_bounded!(usize, i8, i16, i32);
-    try_from_unbounded!(usize, i64, i128);
+    try_from_unbounded!(usize, i64);
 
     try_from_both_bounded!(isize, u8, u16);
-    try_from_lower_bounded!(isize, u32, u64, u128);
+    try_from_lower_bounded!(isize, u32, u64);
     try_from_both_bounded!(isize, i8, i16);
-    try_from_unbounded!(isize, i32, i64, i128);
+    try_from_unbounded!(isize, i32, i64);
 
     rev!(try_from_unbounded, usize, u32);
-    rev!(try_from_upper_bounded, usize, u64, u128);
+    rev!(try_from_upper_bounded, usize, u64);
     rev!(try_from_lower_bounded, usize, i8, i16, i32);
-    rev!(try_from_both_bounded, usize, i64, i128);
+    rev!(try_from_both_bounded, usize, i64);
 
     rev!(try_from_unbounded, isize, u16);
-    rev!(try_from_upper_bounded, isize, u32, u64, u128);
+    rev!(try_from_upper_bounded, isize, u32, u64);
     rev!(try_from_unbounded, isize, i32);
-    rev!(try_from_both_bounded, isize, i64, i128);
+    rev!(try_from_both_bounded, isize, i64);
 }
 
 #[cfg(target_pointer_width = "64")]
@@ -4705,24 +4675,20 @@ mod ptr_try_from_impls {
     use convert::TryFrom;
 
     try_from_upper_bounded!(usize, u8, u16, u32);
-    try_from_unbounded!(usize, u64, u128);
+    try_from_unbounded!(usize, u64);
     try_from_upper_bounded!(usize, i8, i16, i32, i64);
-    try_from_unbounded!(usize, i128);
 
     try_from_both_bounded!(isize, u8, u16, u32);
-    try_from_lower_bounded!(isize, u64, u128);
+    try_from_lower_bounded!(isize, u64);
     try_from_both_bounded!(isize, i8, i16, i32);
-    try_from_unbounded!(isize, i64, i128);
+    try_from_unbounded!(isize, i64);
 
     rev!(try_from_unbounded, usize, u32, u64);
-    rev!(try_from_upper_bounded, usize, u128);
     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);
-    rev!(try_from_both_bounded, usize, i128);
 
     rev!(try_from_unbounded, isize, u16, u32);
-    rev!(try_from_upper_bounded, isize, u64, u128);
+    rev!(try_from_upper_bounded, isize, u64);
     rev!(try_from_unbounded, isize, i32, i64);
-    rev!(try_from_both_bounded, isize, i128);
 }
 
 #[doc(hidden)]
@@ -4757,7 +4723,7 @@ macro_rules! doit {
         }
     })*)
 }
-doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }
+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }
 
 fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {
     use self::IntErrorKind::*;
@@ -4948,52 +4914,38 @@ impl_from_bool! { u8, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { u16, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { u32, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { u64, #[stable(feature = "from_bool", since = "1.28.0")] }
-impl_from_bool! { u128, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { usize, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { i8, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { i16, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { i32, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { i64, #[stable(feature = "from_bool", since = "1.28.0")] }
-impl_from_bool! { i128, #[stable(feature = "from_bool", since = "1.28.0")] }
 impl_from_bool! { isize, #[stable(feature = "from_bool", since = "1.28.0")] }
 
 // Unsigned -> Unsigned
 impl_from! { u8, u16, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { u8, u32, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { u8, u64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { u8, u128, #[stable(feature = "i128", since = "1.26.0")] }
 impl_from! { u8, usize, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { u16, u32, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { u16, u64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { u16, u128, #[stable(feature = "i128", since = "1.26.0")] }
 impl_from! { u32, u64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { u32, u128, #[stable(feature = "i128", since = "1.26.0")] }
-impl_from! { u64, u128, #[stable(feature = "i128", since = "1.26.0")] }
 
 // Signed -> Signed
 impl_from! { i8, i16, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { i8, i32, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { i8, i64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { i8, i128, #[stable(feature = "i128", since = "1.26.0")] }
 impl_from! { i8, isize, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { i16, i32, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { i16, i64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { i16, i128, #[stable(feature = "i128", since = "1.26.0")] }
 impl_from! { i32, i64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { i32, i128, #[stable(feature = "i128", since = "1.26.0")] }
-impl_from! { i64, i128, #[stable(feature = "i128", since = "1.26.0")] }
 
 // Unsigned -> Signed
 impl_from! { u8, i16, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { u8, i32, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { u8, i64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { u8, i128, #[stable(feature = "i128", since = "1.26.0")] }
 impl_from! { u16, i32, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
 impl_from! { u16, i64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { u16, i128, #[stable(feature = "i128", since = "1.26.0")] }
 impl_from! { u32, i64, #[stable(feature = "lossless_int_conv", since = "1.5.0")] }
-impl_from! { u32, i128, #[stable(feature = "i128", since = "1.26.0")] }
-impl_from! { u64, i128, #[stable(feature = "i128", since = "1.26.0")] }
 
 // The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX
 // which imply that pointer-sized integers must be at least 16 bits:
diff --git a/src/libcore/num/wrapping.rs b/src/libcore/num/wrapping.rs
index 50e189c..2da3b35 100644
--- a/src/libcore/num/wrapping.rs
+++ b/src/libcore/num/wrapping.rs
@@ -102,19 +102,17 @@ macro_rules! sh_impl_all {
         //sh_impl_unsigned! { $t, u16 }
         //sh_impl_unsigned! { $t, u32 }
         //sh_impl_unsigned! { $t, u64 }
-        //sh_impl_unsigned! { $t, u128 }
         sh_impl_unsigned! { $t, usize }
 
         //sh_impl_signed! { $t, i8 }
         //sh_impl_signed! { $t, i16 }
         //sh_impl_signed! { $t, i32 }
         //sh_impl_signed! { $t, i64 }
-        //sh_impl_signed! { $t, i128 }
         //sh_impl_signed! { $t, isize }
     )*)
 }
 
-sh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }
+sh_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }
 
 // FIXME(30524): impl Op<T> for Wrapping<T>, impl OpAssign<T> for Wrapping<T>
 macro_rules! wrapping_impl {
@@ -313,7 +311,7 @@ macro_rules! wrapping_impl {
     )*)
 }
 
-wrapping_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 macro_rules! wrapping_int_impl {
     ($($t:ty)*) => ($(
@@ -675,7 +673,7 @@ assert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));
     )*)
 }
 
-wrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+wrapping_int_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 macro_rules! wrapping_int_impl_signed {
     ($($t:ty)*) => ($(
@@ -804,7 +802,7 @@ assert!(!Wrapping(10", stringify!($t), ").is_negative());
     )*)
 }
 
-wrapping_int_impl_signed! { isize i8 i16 i32 i64 i128 }
+wrapping_int_impl_signed! { isize i8 i16 i32 i64 }
 
 macro_rules! wrapping_int_impl_unsigned {
     ($($t:ty)*) => ($(
@@ -881,7 +879,7 @@ assert_eq!(Wrapping(200_u8).next_power_of_two(), Wrapping(0));
     )*)
 }
 
-wrapping_int_impl_unsigned! { usize u8 u16 u32 u64 u128 }
+wrapping_int_impl_unsigned! { usize u8 u16 u32 u64 }
 
 mod shift_max {
     #![allow(non_upper_case_globals)]
@@ -908,13 +906,11 @@ mod shift_max {
     pub const i16: u32 = (1 << 4) - 1;
     pub const i32: u32 = (1 << 5) - 1;
     pub const i64: u32 = (1 << 6) - 1;
-    pub const i128: u32 = (1 << 7) - 1;
     pub use self::platform::isize;
 
     pub const u8: u32 = i8;
     pub const u16: u32 = i16;
     pub const u32: u32 = i32;
     pub const u64: u32 = i64;
-    pub const u128: u32 = i128;
     pub use self::platform::usize;
 }
diff --git a/src/libcore/ops/arith.rs b/src/libcore/ops/arith.rs
index 0252ede..cb8ab3d 100644
--- a/src/libcore/ops/arith.rs
+++ b/src/libcore/ops/arith.rs
@@ -104,7 +104,7 @@ macro_rules! add_impl {
     )*)
 }
 
-add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
 
 /// The subtraction operator `-`.
 ///
@@ -202,7 +202,7 @@ macro_rules! sub_impl {
     )*)
 }
 
-sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
 
 /// The multiplication operator `*`.
 ///
@@ -322,7 +322,7 @@ macro_rules! mul_impl {
     )*)
 }
 
-mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
 
 /// The division operator `/`.
 ///
@@ -447,7 +447,7 @@ macro_rules! div_impl_integer {
     )*)
 }
 
-div_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+div_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 macro_rules! div_impl_float {
     ($($t:ty)*) => ($(
@@ -532,7 +532,7 @@ macro_rules! rem_impl_integer {
     )*)
 }
 
-rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+rem_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 
 macro_rules! rem_impl_float {
@@ -631,7 +631,7 @@ macro_rules! neg_impl_unsigned {
 }
 
 // neg_impl_unsigned! { usize u8 u16 u32 u64 }
-neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }
+neg_impl_numeric! { isize i8 i16 i32 i64 f32 f64 }
 
 /// The addition assignment operator `+=`.
 ///
@@ -687,7 +687,7 @@ macro_rules! add_assign_impl {
     )+)
 }
 
-add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+add_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
 
 /// The subtraction assignment operator `-=`.
 ///
@@ -743,7 +743,7 @@ macro_rules! sub_assign_impl {
     )+)
 }
 
-sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+sub_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
 
 /// The multiplication assignment operator `*=`.
 ///
@@ -790,7 +790,7 @@ macro_rules! mul_assign_impl {
     )+)
 }
 
-mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+mul_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
 
 /// The division assignment operator `/=`.
 ///
@@ -836,7 +836,7 @@ macro_rules! div_assign_impl {
     )+)
 }
 
-div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+div_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
 
 /// The remainder assignment operator `%=`.
 ///
@@ -886,4 +886,4 @@ macro_rules! rem_assign_impl {
     )+)
 }
 
-rem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }
+rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }
diff --git a/src/libcore/ops/bit.rs b/src/libcore/ops/bit.rs
index 2c9bf24..af2ab6f 100644
--- a/src/libcore/ops/bit.rs
+++ b/src/libcore/ops/bit.rs
@@ -55,7 +55,7 @@ macro_rules! not_impl {
     )*)
 }
 
-not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 /// The bitwise AND operator `&`.
 ///
@@ -139,7 +139,7 @@ macro_rules! bitand_impl {
     )*)
 }
 
-bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 /// The bitwise OR operator `|`.
 ///
@@ -223,7 +223,7 @@ macro_rules! bitor_impl {
     )*)
 }
 
-bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 /// The bitwise XOR operator `^`.
 ///
@@ -310,7 +310,7 @@ macro_rules! bitxor_impl {
     )*)
 }
 
-bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 /// The left shift operator `<<`. Note that because this trait is implemented
 /// for all integer types with multiple right-hand-side types, Rust's type
@@ -407,19 +407,17 @@ macro_rules! shl_impl_all {
         shl_impl! { $t, u16 }
         shl_impl! { $t, u32 }
         shl_impl! { $t, u64 }
-        shl_impl! { $t, u128 }
         shl_impl! { $t, usize }
 
         shl_impl! { $t, i8 }
         shl_impl! { $t, i16 }
         shl_impl! { $t, i32 }
         shl_impl! { $t, i64 }
-        shl_impl! { $t, i128 }
         shl_impl! { $t, isize }
     )*)
 }
 
-shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }
+shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }
 
 /// The right shift operator `>>`. Note that because this trait is implemented
 /// for all integer types with multiple right-hand-side types, Rust's type
@@ -516,19 +514,17 @@ macro_rules! shr_impl_all {
         shr_impl! { $t, u16 }
         shr_impl! { $t, u32 }
         shr_impl! { $t, u64 }
-        shr_impl! { $t, u128 }
         shr_impl! { $t, usize }
 
         shr_impl! { $t, i8 }
         shr_impl! { $t, i16 }
         shr_impl! { $t, i32 }
         shr_impl! { $t, i64 }
-        shr_impl! { $t, i128 }
         shr_impl! { $t, isize }
     )*)
 }
 
-shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }
+shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }
 
 /// The bitwise AND assignment operator `&=`.
 ///
@@ -616,7 +612,7 @@ macro_rules! bitand_assign_impl {
     )+)
 }
 
-bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+bitand_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 /// The bitwise OR assignment operator `|=`.
 ///
@@ -665,7 +661,7 @@ macro_rules! bitor_assign_impl {
     )+)
 }
 
-bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+bitor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 /// The bitwise XOR assignment operator `^=`.
 ///
@@ -714,7 +710,7 @@ macro_rules! bitxor_assign_impl {
     )+)
 }
 
-bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }
+bitxor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }
 
 /// The left shift assignment operator `<<=`.
 ///
@@ -770,19 +766,17 @@ macro_rules! shl_assign_impl_all {
         shl_assign_impl! { $t, u16 }
         shl_assign_impl! { $t, u32 }
         shl_assign_impl! { $t, u64 }
-        shl_assign_impl! { $t, u128 }
         shl_assign_impl! { $t, usize }
 
         shl_assign_impl! { $t, i8 }
         shl_assign_impl! { $t, i16 }
         shl_assign_impl! { $t, i32 }
         shl_assign_impl! { $t, i64 }
-        shl_assign_impl! { $t, i128 }
         shl_assign_impl! { $t, isize }
     )*)
 }
 
-shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }
+shl_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }
 
 /// The right shift assignment operator `>>=`.
 ///
@@ -838,16 +832,14 @@ macro_rules! shr_assign_impl_all {
         shr_assign_impl! { $t, u16 }
         shr_assign_impl! { $t, u32 }
         shr_assign_impl! { $t, u64 }
-        shr_assign_impl! { $t, u128 }
         shr_assign_impl! { $t, usize }
 
         shr_assign_impl! { $t, i8 }
         shr_assign_impl! { $t, i16 }
         shr_assign_impl! { $t, i32 }
         shr_assign_impl! { $t, i64 }
-        shr_assign_impl! { $t, i128 }
         shr_assign_impl! { $t, isize }
     )*)
 }
 
-shr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }
+shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }
diff --git a/src/libcore/sync/atomic.rs b/src/libcore/sync/atomic.rs
index 8c5dde7..8122120 100644
--- a/src/libcore/sync/atomic.rs
+++ b/src/libcore/sync/atomic.rs
@@ -2003,36 +2003,6 @@ atomic_int! {
     "AtomicU64::new(0)",
     u64 AtomicU64 ATOMIC_U64_INIT
 }
-#[cfg(target_has_atomic = "128")]
-atomic_int! {
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    "i128", "../../../std/primitive.i128.html",
-    "#![feature(integer_atomics)]\n\n",
-    atomic_min, atomic_max,
-    16,
-    "AtomicI128::new(0)",
-    i128 AtomicI128 ATOMIC_I128_INIT
-}
-#[cfg(target_has_atomic = "128")]
-atomic_int! {
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    unstable(feature = "integer_atomics", issue = "32976"),
-    "u128", "../../../std/primitive.u128.html",
-    "#![feature(integer_atomics)]\n\n",
-    atomic_umin, atomic_umax,
-    16,
-    "AtomicU128::new(0)",
-    u128 AtomicU128 ATOMIC_U128_INIT
-}
 #[cfg(target_pointer_width = "16")]
 macro_rules! ptr_width {
     () => { 2 }
diff --git a/src/libcore/time.rs b/src/libcore/time.rs
index ac7e117..0dfd856 100644
--- a/src/libcore/time.rs
+++ b/src/libcore/time.rs
@@ -21,7 +21,6 @@ const NANOS_PER_MILLI: u32 = 1_000_000;
 const NANOS_PER_MICRO: u32 = 1_000;
 const MILLIS_PER_SEC: u64 = 1_000;
 const MICROS_PER_SEC: u64 = 1_000_000;
-const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;
 
 /// The duration of one second.
 #[unstable(feature = "duration_constants", issue = "57391")]
@@ -276,54 +275,6 @@ impl Duration {
     #[inline]
     pub const fn subsec_nanos(&self) -> u32 { self.nanos }
 
-    /// Returns the total number of whole milliseconds contained by this `Duration`.
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use std::time::Duration;
-    ///
-    /// let duration = Duration::new(5, 730023852);
-    /// assert_eq!(duration.as_millis(), 5730);
-    /// ```
-    #[stable(feature = "duration_as_u128", since = "1.33.0")]
-    #[inline]
-    pub const fn as_millis(&self) -> u128 {
-        self.secs as u128 * MILLIS_PER_SEC as u128 + (self.nanos / NANOS_PER_MILLI) as u128
-    }
-
-    /// Returns the total number of whole microseconds contained by this `Duration`.
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use std::time::Duration;
-    ///
-    /// let duration = Duration::new(5, 730023852);
-    /// assert_eq!(duration.as_micros(), 5730023);
-    /// ```
-    #[stable(feature = "duration_as_u128", since = "1.33.0")]
-    #[inline]
-    pub const fn as_micros(&self) -> u128 {
-        self.secs as u128 * MICROS_PER_SEC as u128 + (self.nanos / NANOS_PER_MICRO) as u128
-    }
-
-    /// Returns the total number of nanoseconds contained by this `Duration`.
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use std::time::Duration;
-    ///
-    /// let duration = Duration::new(5, 730023852);
-    /// assert_eq!(duration.as_nanos(), 5730023852);
-    /// ```
-    #[stable(feature = "duration_as_u128", since = "1.33.0")]
-    #[inline]
-    pub const fn as_nanos(&self) -> u128 {
-        self.secs as u128 * NANOS_PER_SEC as u128 + self.nanos as u128
-    }
-
     /// Checked `Duration` addition. Computes `self + other`, returning [`None`]
     /// if overflow occurred.
     ///
@@ -482,80 +433,6 @@ impl Duration {
         (self.secs as f64) + (self.nanos as f64) / (NANOS_PER_SEC as f64)
     }
 
-    /// Creates a new `Duration` from the specified number of seconds.
-    ///
-    /// # Panics
-    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.
-    ///
-    /// # Examples
-    /// ```
-    /// #![feature(duration_float)]
-    /// use std::time::Duration;
-    ///
-    /// let dur = Duration::from_float_secs(2.7);
-    /// assert_eq!(dur, Duration::new(2, 700_000_000));
-    /// ```
-    #[unstable(feature = "duration_float", issue = "54361")]
-    #[inline]
-    pub fn from_float_secs(secs: f64) -> Duration {
-        let nanos =  secs * (NANOS_PER_SEC as f64);
-        if !nanos.is_finite() {
-            panic!("got non-finite value when converting float to duration");
-        }
-        if nanos >= MAX_NANOS_F64 {
-            panic!("overflow when converting float to duration");
-        }
-        if nanos < 0.0 {
-            panic!("underflow when converting float to duration");
-        }
-        let nanos =  nanos as u128;
-        Duration {
-            secs: (nanos / (NANOS_PER_SEC as u128)) as u64,
-            nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,
-        }
-    }
-
-    /// Multiplies `Duration` by `f64`.
-    ///
-    /// # Panics
-    /// This method will panic if result is not finite, negative or overflows `Duration`.
-    ///
-    /// # Examples
-    /// ```
-    /// #![feature(duration_float)]
-    /// use std::time::Duration;
-    ///
-    /// let dur = Duration::new(2, 700_000_000);
-    /// assert_eq!(dur.mul_f64(3.14), Duration::new(8, 478_000_000));
-    /// assert_eq!(dur.mul_f64(3.14e5), Duration::new(847_800, 0));
-    /// ```
-    #[unstable(feature = "duration_float", issue = "54361")]
-    #[inline]
-    pub fn mul_f64(self, rhs: f64) -> Duration {
-        Duration::from_float_secs(rhs * self.as_float_secs())
-    }
-
-    /// Divide `Duration` by `f64`.
-    ///
-    /// # Panics
-    /// This method will panic if result is not finite, negative or overflows `Duration`.
-    ///
-    /// # Examples
-    /// ```
-    /// #![feature(duration_float)]
-    /// use std::time::Duration;
-    ///
-    /// let dur = Duration::new(2, 700_000_000);
-    /// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));
-    /// // note that truncation is used, not rounding
-    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_598));
-    /// ```
-    #[unstable(feature = "duration_float", issue = "54361")]
-    #[inline]
-    pub fn div_f64(self, rhs: f64) -> Duration {
-        Duration::from_float_secs(self.as_float_secs() / rhs)
-    }
-
     /// Divide `Duration` by `Duration` and return `f64`.
     ///
     /// # Examples
diff --git a/src/libstd/lib.rs b/src/libstd/lib.rs
index 9a4232d..592fea0 100644
--- a/src/libstd/lib.rs
+++ b/src/libstd/lib.rs
@@ -392,8 +392,6 @@ pub use core::i16;
 pub use core::i32;
 #[stable(feature = "rust1", since = "1.0.0")]
 pub use core::i64;
-#[stable(feature = "i128", since = "1.26.0")]
-pub use core::i128;
 #[stable(feature = "rust1", since = "1.0.0")]
 pub use core::usize;
 #[stable(feature = "rust1", since = "1.0.0")]
@@ -426,8 +424,6 @@ pub use alloc_crate::string;
 pub use alloc_crate::vec;
 #[stable(feature = "rust1", since = "1.0.0")]
 pub use core::char;
-#[stable(feature = "i128", since = "1.26.0")]
-pub use core::u128;
 #[stable(feature = "core_hint", since = "1.27.0")]
 pub use core::hint;
 
diff --git a/src/libstd/net/ip.rs b/src/libstd/net/ip.rs
index c856129..2bfe9cb 100644
--- a/src/libstd/net/ip.rs
+++ b/src/libstd/net/ip.rs
@@ -1391,48 +1391,6 @@ impl FromInner<c::in6_addr> for Ipv6Addr {
     }
 }
 
-#[stable(feature = "i128", since = "1.26.0")]
-impl From<Ipv6Addr> for u128 {
-    /// Convert an `Ipv6Addr` into a host byte order `u128`.
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use std::net::Ipv6Addr;
-    ///
-    /// let addr = Ipv6Addr::new(
-    ///     0x1020, 0x3040, 0x5060, 0x7080,
-    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,
-    /// );
-    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));
-    /// ```
-    fn from(ip: Ipv6Addr) -> u128 {
-        let ip = ip.octets();
-        u128::from_be_bytes(ip)
-    }
-}
-#[stable(feature = "i128", since = "1.26.0")]
-impl From<u128> for Ipv6Addr {
-    /// Convert a host byte order `u128` into an `Ipv6Addr`.
-    ///
-    /// # Examples
-    ///
-    /// ```
-    /// use std::net::Ipv6Addr;
-    ///
-    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);
-    /// assert_eq!(
-    ///     Ipv6Addr::new(
-    ///         0x1020, 0x3040, 0x5060, 0x7080,
-    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,
-    ///     ),
-    ///     addr);
-    /// ```
-    fn from(ip: u128) -> Ipv6Addr {
-        Ipv6Addr::from(ip.to_be_bytes())
-    }
-}
-
 #[stable(feature = "ipv6_from_octets", since = "1.9.0")]
 impl From<[u8; 16]> for Ipv6Addr {
     fn from(octets: [u8; 16]) -> Ipv6Addr {
diff --git a/src/libstd/num.rs b/src/libstd/num.rs
index c80b9a5..e32a6b3 100644
--- a/src/libstd/num.rs
+++ b/src/libstd/num.rs
@@ -12,7 +12,7 @@ pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError}
 pub use core::num::Wrapping;
 
 #[stable(feature = "nonzero", since = "1.28.0")]
-pub use core::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize};
+pub use core::num::{NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroUsize};
 
 #[cfg(test)] use fmt;
 #[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};
diff --git a/src/libstd/panic.rs b/src/libstd/panic.rs
index 862fdf0..171ebeb 100644
--- a/src/libstd/panic.rs
+++ b/src/libstd/panic.rs
@@ -254,9 +254,6 @@ impl RefUnwindSafe for atomic::AtomicI32 {}
 #[cfg(target_has_atomic = "64")]
 #[unstable(feature = "integer_atomics", issue = "32976")]
 impl RefUnwindSafe for atomic::AtomicI64 {}
-#[cfg(target_has_atomic = "128")]
-#[unstable(feature = "integer_atomics", issue = "32976")]
-impl RefUnwindSafe for atomic::AtomicI128 {}
 
 #[cfg(target_has_atomic = "ptr")]
 #[stable(feature = "unwind_safe_atomic_refs", since = "1.14.0")]
@@ -273,9 +270,6 @@ impl RefUnwindSafe for atomic::AtomicU32 {}
 #[cfg(target_has_atomic = "64")]
 #[unstable(feature = "integer_atomics", issue = "32976")]
 impl RefUnwindSafe for atomic::AtomicU64 {}
-#[cfg(target_has_atomic = "128")]
-#[unstable(feature = "integer_atomics", issue = "32976")]
-impl RefUnwindSafe for atomic::AtomicU128 {}
 
 #[cfg(target_has_atomic = "8")]
 #[stable(feature = "unwind_safe_atomic_refs", since = "1.14.0")]
-- 
2.17.2 (Apple Git-113)
