    1|       |#![allow(unused_assignments)]
    2|       |
    3|       |// require-rust-edition-2018
    4|       |
    5|      1|async fn f() -> u8 { 1 }
    6|       |
    7|       |async fn foo() -> [bool; 10] { [false; 10] }
    8|       |
    9|       |pub async fn g(x: u8) {
   10|       |    match x {
   11|       |        y if f().await == y => (),
   12|       |        _ => (),
   13|       |    }
   14|      1|}
   15|       |
   16|       |// #78366: check the reference to the binding is recorded even if the binding is not autorefed
   17|       |
   18|       |async fn h(x: usize) {
   19|       |    match x {
   20|       |        y if foo().await[y] => (),
   21|       |        _ => (),
   22|       |    }
   23|      1|}
   24|       |
   25|      1|async fn i(x: u8) {
   26|      1|    match x {
   27|      1|        y if f().await == y + 1 => (),
                      ^0                         ^0
   28|      1|        _ => (),
   29|       |    }
   30|      2|}
   31|       |
   32|      1|fn main() {
   33|      1|    let _ = g(10);
   34|      1|    let _ = h(9);
   35|      1|    let mut future = Box::pin(i(8));
   36|      1|    executor::block_on(future.as_mut());
   37|      1|}
   38|       |
   39|       |mod executor {
   40|       |    use core::{
   41|       |        future::Future,
   42|       |        pin::Pin,
   43|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},
   44|       |    };
   45|       |
   46|       |    pub fn block_on<F: Future>(mut future: F) -> F::Output {
   47|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };
   48|      1|
   49|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(
   50|      1|            |_| unimplemented!("clone"),
   51|      1|            |_| unimplemented!("wake"),
   52|      1|            |_| unimplemented!("wake_by_ref"),
   53|      1|            |_| (),
   54|      1|        );
   55|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };
   56|      1|        let mut context = Context::from_waker(&waker);
   57|       |
   58|       |        loop {
   59|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {
   60|      1|                break val;
   61|       |            }
   62|      0|        }
   63|      1|    }
   64|       |}

