error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:16:14
   |
LL |     unsafe { copy_nonoverlapping::<u8>(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `-D clippy::unsafe-sizeof-count-copies` implied by `-D warnings`
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:17:14
   |
LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:19:14
   |
LL |     unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:20:14
   |
LL |     unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:21:14
   |
LL |     unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:22:14
   |
LL |     unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:24:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:25:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:27:14
   |
LL |     unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u8>() * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:28:14
   |
LL |     unsafe { write_bytes(y.as_mut_ptr(), 0u8, size_of::<u8>() * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:30:14
   |
LL |     unsafe { swap_nonoverlapping(y.as_mut_ptr(), x.as_mut_ptr(), size_of::<u8>() * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:32:14
   |
LL |     unsafe { slice_from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:33:14
   |
LL |     unsafe { slice_from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:36:14
   |
LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:37:14
   |
LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:39:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:40:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:43:14
   |
LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * HALF_SIZE * 2) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:44:14
   |
LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), HALF_SIZE * size_of_val(&x[0]) * 2) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:46:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE * HALF_SIZE) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:47:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * HALF_SIZE * 2) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:50:14
   |
LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * DOUBLE_SIZE / 2) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:51:14
   |
LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE / 2 * size_of_val(&x[0])) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:53:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE * size_of::<u8>() / 2) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T
  --> $DIR/unsafe_sizeof_count_copies.rs:54:14
   |
LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * DOUBLE_SIZE / 2) };
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type

error: aborting due to 25 previous errors

