    1|       |#![allow(unused_assignments, unused_variables)]
    2|       |
    3|       |fn main() {
    4|      1|    let mut countdown = 0;
    5|      1|    if true {
    6|      1|        countdown = 10;
    7|      1|    }
    8|       |
    9|       |    const B: u32 = 100;
   10|      1|    let x = if countdown > 7 {
   11|      1|        countdown -= 4;
   12|      1|        B
   13|      0|    } else if countdown > 2 {
   14|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   15|      0|            countdown = 0;
   16|      0|        }
   17|      0|        countdown -= 5;
   18|      0|        countdown
   19|       |    } else {
   20|      0|        return;
   21|       |    };
   22|       |
   23|      1|    let mut countdown = 0;
   24|      1|    if true {
   25|      1|        countdown = 10;
   26|      1|    }
   27|       |
   28|      1|    if countdown > 7 {
   29|      1|        countdown -= 4;
   30|      1|    } else if countdown > 2 {
                            ^0
   31|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   32|      0|            countdown = 0;
   33|      0|        }
   34|      0|        countdown -= 5;
   35|       |    } else {
   36|      0|        return;
   37|       |    }
   38|       |
   39|      1|    if true {
   40|       |        // Demonstrate the difference with `TerminatorKind::Assert` as of 2020-11-15. Assert is no
   41|       |        // longer treated as a `BasicCoverageBlock` terminator, which changed the coverage region,
   42|       |        // for the executed `then` block above, to include the closing brace on line 30. That
   43|       |        // changed the line count, but the coverage code region (for the `else if` condition) is
   44|       |        // still valid.
   45|       |        //
   46|       |        // Note that `if` (then) and `else` blocks include the closing brace in their coverage
   47|       |        // code regions when the last line in the block ends in a semicolon, because the Rust
   48|       |        // compiler inserts a `StatementKind::Assign` to assign `const ()` to a `Place`, for the
   49|       |        // empty value for the executed block. When the last line does not end in a semicolon
   50|       |        // (that is, when the block actually results in a value), the additional `Assign` is not
   51|       |        // generated, and the brace is not included.
   52|      1|        let mut countdown = 0;
   53|      1|        if true {
   54|      1|            countdown = 10;
   55|      1|        }
   56|       |
   57|      1|        if countdown > 7 {
   58|      1|            countdown -= 4;
   59|      1|        }
   60|       |        // The closing brace of the `then` branch is now included in the coverage region, and shown
   61|       |        // as "executed" (giving its line a count of 1 here). Since, in the original version above,
   62|       |        // the closing brace shares the same line as the `else if` conditional expression (which is
   63|       |        // not executed if the first `then` condition is true), only the condition's code region is
   64|       |        // marked with a count of 0 now.
   65|      0|        else if countdown > 2 {
   66|      0|            if countdown < 1 || countdown > 5 || countdown != 9 {
   67|      0|                countdown = 0;
   68|      0|            }
   69|      0|            countdown -= 5;
   70|       |        } else {
   71|      0|            return;
   72|       |        }
   73|      1|    }
   74|       |
   75|      1|    let mut countdown = 0;
   76|      1|    if true {
   77|      1|        countdown = 1;
   78|      1|    }
   79|       |
   80|      1|    let z = if countdown > 7 {
                      ^0
   81|      0|        countdown -= 4;
   82|      1|    } else if countdown > 2 {
   83|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   84|      0|            countdown = 0;
   85|      0|        }
   86|      0|        countdown -= 5;
   87|       |    } else {
   88|      1|        let should_be_reachable = countdown;
   89|      1|        println!("reached");
   90|      1|        return;
   91|       |    };
   92|       |
   93|      0|    let w = if countdown > 7 {
   94|      0|        countdown -= 4;
   95|      0|    } else if countdown > 2 {
   96|      0|        if countdown < 1 || countdown > 5 || countdown != 9 {
   97|      0|            countdown = 0;
   98|      0|        }
   99|      0|        countdown -= 5;
  100|       |    } else {
  101|      0|        return;
  102|       |    };
  103|      1|}

