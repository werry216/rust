An underscore `_` character has been used as the identifier for a lifetime,
or a const generic has been borrowed without an explicit lifetime.

Erroneous example with an underscore:
```compile_fail,E0106,E0637
fn foo<'_>(str1: &'_ str, str2: &'_ str) -> &'_ str {}
    // ^^ `'_` is a reserved lifetime name
```
Lifetimes are named with `'ident`, where ident is the name of the lifetime or
loop. The `_` character, which represents the ignore pattern, cannot be used
as the identifier because it is a reserved lifetime name. To fix
this, use a lowercase letter, or a series of lowercase letters as the lifetime
identifier. Often a single lowercase letter, such as `'a`, is sufficient.  For
more information, see [the book][bk-no].

Corrected underscore example:
```
fn foo<'a>(str1: &'a str, str2: &'a str) -> &'a str {}
```

Erroneous example with const generic:
```compile_fail,E0261,E0637,E0658
struct A<const N: &u8>;
//~^ ERROR `&` without an explicit lifetime name cannot be used here
trait B {}

impl<const N: &u8> A<N> {
//~^ ERROR `&` without an explicit lifetime name cannot be used here
    fn foo<const M: &u8>(&self) {}
    //~^ ERROR `&` without an explicit lifetime name cannot be used here
}

impl<const N: &u8> B for A<N> {}
//~^ ERROR `&` without an explicit lifetime name cannot be used here

fn bar<const N: &u8>() {}
//~^ ERROR `&` without an explicit lifetime name cannot be used here
```

Const generics cannot be borrowed without specifying a lifetime.The
compiler handles memory allocation of constants differently than that of
variables and it cannot infer the lifetime of the borrowed constant.
To fix this, explicitly specify a lifetime for the const generic.

Corrected const generic example:
```
struct A<const N: &'a u8>;

trait B {}

impl<const N: &'a u8> A<N> {
    fn foo<const M: &'a u8>(&self) {}
}

impl<const N: &'a u8> B for A<N> {}

fn bar<const N: &'a u8>() {}
```
[bk-no]: https://doc.rust-lang.org/book/appendix-02-operators.html#non-operator-symbols
